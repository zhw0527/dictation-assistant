# å¬å†™åŠ©ç† - ç«‹å³å¯å®æ–½çš„ä»£ç ä¼˜åŒ–æ¸…å•

## ğŸš€ ä¼˜å…ˆçº§ P0ï¼ˆæœ¬å‘¨å®Œæˆï¼‰

### 1. é›†æˆè¯­éŸ³è¯„æµ‹åŠŸèƒ½

**æ–‡ä»¶**: `utils/voice-evaluation.js`

```javascript
// æ–°å»ºæ–‡ä»¶ï¼šutils/voice-evaluation.js
const config = require('../config')

/**
 * è¯­éŸ³è¯„æµ‹å·¥å…·
 * å‚è€ƒï¼šCodeShockWave/Wechat-Mini-Program
 */
class VoiceEvaluation {
  constructor() {
    this.apiUrl = 'https://aip.baidubce.com/rpc/2.0/aasr/v1/evaluate'
  }

  /**
   * è¯„æµ‹å‘éŸ³
   * @param {ArrayBuffer} audioData - éŸ³é¢‘æ•°æ®
   * @param {string} text - æ ‡å‡†æ–‡æœ¬
   * @param {string} mode - è¯„æµ‹æ¨¡å¼ï¼šword/sentence
   */
  async evaluate(audioData, text, mode = 'word') {
    try {
      const token = await this.getAccessToken()
      
      const response = await wx.request({
        url: `${this.apiUrl}?access_token=${token}`,
        method: 'POST',
        data: {
          audio: this.arrayBufferToBase64(audioData),
          text: text,
          mode: mode,
          cuid: 'dictation-assistant'
        }
      })

      return {
        score: response.data.score || 0,           // å‡†ç¡®åº¦ 0-100
        fluency: response.data.fluency || 0,       // æµåˆ©åº¦ 0-100
        completeness: response.data.completeness || 0,  // å®Œæ•´åº¦ 0-100
        details: response.data.details || []
      }
    } catch (error) {
      console.error('è¯­éŸ³è¯„æµ‹å¤±è´¥:', error)
      return null
    }
  }

  /**
   * è·å–ç™¾åº¦ Access Token
   */
  async getAccessToken() {
    // å®ç° token è·å–é€»è¾‘
    // å¯ä»¥ç¼“å­˜ tokenï¼Œé¿å…é¢‘ç¹è¯·æ±‚
    const cacheKey = 'baidu_access_token'
    let token = wx.getStorageSync(cacheKey)
    
    if (!token) {
      const response = await wx.request({
        url: 'https://aip.baidubce.com/oauth/2.0/token',
        data: {
          grant_type: 'client_credentials',
          client_id: config.baiduTTS.apiKey,
          client_secret: config.baiduTTS.secretKey
        }
      })
      
      token = response.data.access_token
      wx.setStorageSync(cacheKey, token)
    }
    
    return token
  }

  /**
   * ArrayBuffer è½¬ Base64
   */
  arrayBufferToBase64(buffer) {
    let binary = ''
    const bytes = new Uint8Array(buffer)
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }
    return wx.arrayBufferToBase64(buffer)
  }
}

module.exports = new VoiceEvaluation()
```

**ä¿®æ”¹æ–‡ä»¶**: `pages/dictation/dictation.js`

```javascript
// åœ¨æ–‡ä»¶é¡¶éƒ¨æ·»åŠ 
const voiceEvaluation = require('../../utils/voice-evaluation')

// æ·»åŠ å½•éŸ³åŠŸèƒ½
data: {
  // ... ç°æœ‰æ•°æ®
  isRecording: false,
  recordManager: null
},

onLoad() {
  // åˆå§‹åŒ–å½•éŸ³ç®¡ç†å™¨
  this.data.recordManager = wx.getRecorderManager()
  
  this.data.recordManager.onStop((res) => {
    this.handleRecordStop(res)
  })
},

// å¼€å§‹å½•éŸ³
startRecord() {
  this.setData({ isRecording: true })
  
  this.data.recordManager.start({
    duration: 10000,
    sampleRate: 16000,
    numberOfChannels: 1,
    encodeBitRate: 48000,
    format: 'mp3'
  })
},

// åœæ­¢å½•éŸ³
stopRecord() {
  this.setData({ isRecording: false })
  this.data.recordManager.stop()
},

// å¤„ç†å½•éŸ³ç»“æœ
async handleRecordStop(res) {
  wx.showLoading({ title: 'è¯„æµ‹ä¸­...' })
  
  try {
    const result = await voiceEvaluation.evaluate(
      res.tempFilePath,
      this.data.currentWord,
      'word'
    )
    
    wx.hideLoading()
    
    if (result && result.score >= 60) {
      wx.showToast({
        title: `å‘éŸ³å¾—åˆ†: ${result.score}åˆ†`,
        icon: 'success'
      })
    } else {
      wx.showToast({
        title: 'å‘éŸ³éœ€è¦æ”¹è¿›',
        icon: 'none'
      })
    }
  } catch (error) {
    wx.hideLoading()
    wx.showToast({
      title: 'è¯„æµ‹å¤±è´¥',
      icon: 'none'
    })
  }
}
```

---

### 2. æ·»åŠ æ¸¸æˆåŒ–ç§¯åˆ†ç³»ç»Ÿ

**æ–‡ä»¶**: `utils/points-system.js`

```javascript
/**
 * ç§¯åˆ†ç³»ç»Ÿ
 * å‚è€ƒå°çŒ¿å£ç®—çš„æ¸¸æˆåŒ–è®¾è®¡
 */
class PointsSystem {
  constructor() {
    this.POINTS_CONFIG = {
      CORRECT_ANSWER: 10,      // ç­”å¯¹åŸºç¡€åˆ†
      PERFECT_SCORE: 20,       // å®Œç¾ç­”æ¡ˆé¢å¤–åˆ†
      SPEED_BONUS: 5,          // å¿«é€Ÿç­”é¢˜å¥–åŠ±
      STREAK_MULTIPLIER: 2,    // è¿å‡»å€æ•°
      FIRST_TRY: 15           // ä¸€æ¬¡ç­”å¯¹å¥–åŠ±
    }
  }

  /**
   * è®¡ç®—å¾—åˆ†
   * @param {Object} result - ç­”é¢˜ç»“æœ
   * @param {boolean} result.isCorrect - æ˜¯å¦æ­£ç¡®
   * @param {number} result.score - è¯„åˆ†ï¼ˆ0-100ï¼‰
   * @param {number} result.time - ç”¨æ—¶ï¼ˆæ¯«ç§’ï¼‰
   * @param {number} streak - å½“å‰è¿å‡»æ•°
   * @param {number} attempts - å°è¯•æ¬¡æ•°
   */
  calculatePoints(result, streak = 0, attempts = 1) {
    let points = 0
    
    if (!result.isCorrect) {
      return 0
    }
    
    // åŸºç¡€åˆ†
    points += this.POINTS_CONFIG.CORRECT_ANSWER
    
    // å®Œç¾åˆ†æ•°å¥–åŠ±
    if (result.score === 100) {
      points += this.POINTS_CONFIG.PERFECT_SCORE
    }
    
    // é€Ÿåº¦å¥–åŠ±ï¼ˆ5ç§’å†…å®Œæˆï¼‰
    if (result.time && result.time < 5000) {
      points += this.POINTS_CONFIG.SPEED_BONUS
    }
    
    // è¿å‡»å¥–åŠ±
    if (streak > 0) {
      points += streak * this.POINTS_CONFIG.STREAK_MULTIPLIER
    }
    
    // ä¸€æ¬¡ç­”å¯¹å¥–åŠ±
    if (attempts === 1) {
      points += this.POINTS_CONFIG.FIRST_TRY
    }
    
    return points
  }

  /**
   * æ›´æ–°ç”¨æˆ·ç§¯åˆ†
   */
  updateUserPoints(userId, points) {
    const currentPoints = wx.getStorageSync(`user_points_${userId}`) || 0
    const newPoints = currentPoints + points
    
    wx.setStorageSync(`user_points_${userId}`, newPoints)
    
    // æ£€æŸ¥æ˜¯å¦è§£é”æ–°æˆå°±
    this.checkAchievements(userId, newPoints)
    
    return newPoints
  }

  /**
   * æ£€æŸ¥æˆå°±
   */
  checkAchievements(userId, totalPoints) {
    const achievements = [
      { id: 'beginner', name: 'åˆå­¦è€…', points: 100, icon: 'ğŸŒ±' },
      { id: 'intermediate', name: 'è¿›é˜¶è€…', points: 500, icon: 'ğŸŒ¿' },
      { id: 'advanced', name: 'é«˜æ‰‹', points: 1000, icon: 'ğŸŒ³' },
      { id: 'master', name: 'å¤§å¸ˆ', points: 5000, icon: 'ğŸ†' },
      { id: 'legend', name: 'ä¼ å¥‡', points: 10000, icon: 'ğŸ‘‘' }
    ]
    
    const unlockedAchievements = wx.getStorageSync(`achievements_${userId}`) || []
    
    achievements.forEach(achievement => {
      if (totalPoints >= achievement.points && 
          !unlockedAchievements.includes(achievement.id)) {
        // è§£é”æ–°æˆå°±
        unlockedAchievements.push(achievement.id)
        wx.setStorageSync(`achievements_${userId}`, unlockedAchievements)
        
        // æ˜¾ç¤ºæˆå°±é€šçŸ¥
        wx.showToast({
          title: `ğŸ‰ è§£é”æˆå°±ï¼š${achievement.icon} ${achievement.name}`,
          icon: 'none',
          duration: 3000
        })
      }
    })
  }

  /**
   * è·å–ç”¨æˆ·ç­‰çº§
   */
  getUserLevel(totalPoints) {
    const levels = [
      { level: 1, name: 'é’é“œ', minPoints: 0, maxPoints: 99 },
      { level: 2, name: 'ç™½é“¶', minPoints: 100, maxPoints: 499 },
      { level: 3, name: 'é»„é‡‘', minPoints: 500, maxPoints: 999 },
      { level: 4, name: 'é“‚é‡‘', minPoints: 1000, maxPoints: 4999 },
      { level: 5, name: 'é’»çŸ³', minPoints: 5000, maxPoints: 9999 },
      { level: 6, name: 'ç‹è€…', minPoints: 10000, maxPoints: Infinity }
    ]
    
    return levels.find(l => totalPoints >= l.minPoints && totalPoints <= l.maxPoints)
  }
}

module.exports = new PointsSystem()
```

**ä¿®æ”¹**: `pages/dictation/dictation.js`

```javascript
const pointsSystem = require('../../utils/points-system')

data: {
  // ... ç°æœ‰æ•°æ®
  streak: 0,           // è¿å‡»æ•°
  totalPoints: 0,      // æ€»ç§¯åˆ†
  sessionPoints: 0     // æœ¬æ¬¡ç§¯åˆ†
},

// ä¿®æ”¹ nextWord æ–¹æ³•
nextWord() {
  const { currentIndex, wordList, userInput, currentWord, answers, streak } = this.data
  
  const isCorrect = userInput === currentWord
  const result = {
    isCorrect: isCorrect,
    score: isCorrect ? 100 : 0,
    time: Date.now() - this.startTime
  }
  
  // è®¡ç®—ç§¯åˆ†
  const points = pointsSystem.calculatePoints(result, streak, 1)
  
  // æ›´æ–°è¿å‡»
  const newStreak = isCorrect ? streak + 1 : 0
  
  // æ›´æ–°ç§¯åˆ†
  const sessionPoints = this.data.sessionPoints + points
  const totalPoints = pointsSystem.updateUserPoints('current_user', points)
  
  // ä¿å­˜ç­”æ¡ˆ
  answers.push({
    word: currentWord,
    answer: userInput,
    correct: isCorrect,
    points: points
  })

  this.setData({
    streak: newStreak,
    sessionPoints: sessionPoints,
    totalPoints: totalPoints,
    answers: answers
  })

  // æ˜¾ç¤ºç§¯åˆ†åŠ¨ç”»
  if (points > 0) {
    this.showPointsAnimation(points)
  }

  // ç»§ç»­ä¸‹ä¸€ä¸ª
  if (currentIndex < wordList.length - 1) {
    this.setData({
      currentIndex: currentIndex + 1,
      userInput: ''
    })
    this.loadWord()
  } else {
    this.finishDictation()
  }
},

// æ˜¾ç¤ºç§¯åˆ†åŠ¨ç”»
showPointsAnimation(points) {
  wx.showToast({
    title: `+${points} åˆ†ï¼`,
    icon: 'none',
    duration: 1000
  })
}
```

---

### 3. ä¼˜åŒ– UI åŠ¨ç”»æ•ˆæœ

**æ–‡ä»¶**: `pages/dictation/dictation.wxml`

```xml
<!-- æ·»åŠ ç§¯åˆ†æ˜¾ç¤º -->
<view class="points-display">
  <view class="total-points">
    <text class="points-label">æ€»ç§¯åˆ†</text>
    <text class="points-value">{{totalPoints}}</text>
  </view>
  <view class="session-points">
    <text class="session-label">æœ¬æ¬¡</text>
    <text class="session-value">+{{sessionPoints}}</text>
  </view>
  <view class="streak-display" wx:if="{{streak > 0}}">
    <text class="streak-icon">ğŸ”¥</text>
    <text class="streak-value">{{streak}} è¿å‡»</text>
  </view>
</view>

<!-- ç­”é¢˜åŒºåŸŸæ·»åŠ åŠ¨ç”» -->
<view class="word-display {{answerAnimation}}">
  <text class="current-word">{{currentWord || 'å‡†å¤‡å¼€å§‹'}}</text>
  <text class="word-index">{{currentIndex + 1}} / {{wordList.length}}</text>
</view>

<!-- æ·»åŠ å½•éŸ³æŒ‰é’® -->
<view class="voice-input" wx:if="{{isStarted}}">
  <button 
    class="btn-record {{isRecording ? 'recording' : ''}}" 
    bindtouchstart="startRecord"
    bindtouchend="stopRecord"
  >
    {{isRecording ? 'ğŸ¤ å½•éŸ³ä¸­...' : 'ğŸ¤ è¯­éŸ³ç­”é¢˜'}}
  </button>
</view>
```

**æ–‡ä»¶**: `pages/dictation/dictation.wxss`

```css
/* ç§¯åˆ†æ˜¾ç¤º */
.points-display {
  display: flex;
  justify-content: space-around;
  padding: 20rpx;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 16rpx;
  margin-bottom: 20rpx;
}

.total-points, .session-points {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.points-value {
  font-size: 48rpx;
  font-weight: bold;
  margin-top: 10rpx;
}

.session-value {
  font-size: 32rpx;
  color: #FFD700;
  margin-top: 10rpx;
}

.streak-display {
  display: flex;
  align-items: center;
  gap: 10rpx;
  animation: pulse 1s infinite;
}

.streak-icon {
  font-size: 40rpx;
}

.streak-value {
  font-size: 28rpx;
  font-weight: bold;
}

/* ç­”å¯¹åŠ¨ç”» */
@keyframes correct-answer {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); background: #52c41a; }
  100% { transform: scale(1); }
}

/* ç­”é”™åŠ¨ç”» */
@keyframes wrong-answer {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-10rpx); }
  75% { transform: translateX(10rpx); }
}

/* è¿å‡»åŠ¨ç”» */
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

/* å½•éŸ³æŒ‰é’® */
.btn-record {
  width: 100%;
  padding: 30rpx;
  border-radius: 50rpx;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  font-size: 32rpx;
  border: none;
  box-shadow: 0 8rpx 16rpx rgba(102, 126, 234, 0.3);
  transition: all 0.3s;
}

.btn-record.recording {
  background: #ff4d4f;
  animation: recording-pulse 1s infinite;
}

@keyframes recording-pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255, 77, 79, 0.7); }
  50% { box-shadow: 0 0 0 20rpx rgba(255, 77, 79, 0); }
}
```

---

## ğŸ¯ ä¼˜å…ˆçº§ P1ï¼ˆä¸‹å‘¨å®Œæˆï¼‰

### 4. æ‹ç…§æ‰¹æ”¹åŠŸèƒ½

**æ–‡ä»¶**: `pages/dictation/dictation.wxml`

```xml
<button class="btn-camera" bindtap="takePhoto">
  ğŸ“· æ‹ç…§æ‰¹æ”¹
</button>
```

**æ–‡ä»¶**: `pages/dictation/dictation.js`

```javascript
const api = require('../../utils/api')

// æ‹ç…§æ‰¹æ”¹
takePhoto() {
  wx.chooseImage({
    count: 1,
    sizeType: ['compressed'],
    sourceType: ['camera', 'album'],
    success: (res) => {
      this.handlePhotoCorrection(res.tempFilePaths[0])
    }
  })
},

async handlePhotoCorrection(imagePath) {
  wx.showLoading({ title: 'è¯†åˆ«ä¸­...' })
  
  try {
    // è¯»å–å›¾ç‰‡ä¸º base64
    const fs = wx.getFileSystemManager()
    const imageData = fs.readFileSync(imagePath, 'base64')
    
    // è°ƒç”¨ OCR è¯†åˆ«
    const result = await api.recognizeText(imageData)
    
    wx.hideLoading()
    
    // å¯¹æ¯”ç­”æ¡ˆ
    this.compareAnswers(result.texts)
    
  } catch (error) {
    wx.hideLoading()
    wx.showToast({
      title: 'è¯†åˆ«å¤±è´¥',
      icon: 'none'
    })
  }
},

compareAnswers(recognizedTexts) {
  const { wordList } = this.data
  const results = []
  
  recognizedTexts.forEach((text, index) => {
    if (index < wordList.length) {
      const isCorrect = text.trim() === wordList[index]
      results.push({
        word: wordList[index],
        answer: text,
        correct: isCorrect
      })
    }
  })
  
  // æ˜¾ç¤ºæ‰¹æ”¹ç»“æœ
  this.showCorrectionResults(results)
}
```

---

### 5. æ’è¡Œæ¦œåŠŸèƒ½

**æ–‡ä»¶**: `pages/ranking/ranking.wxml`

```xml
<view class="ranking-container">
  <view class="ranking-header">
    <text class="ranking-title">ğŸ† æ’è¡Œæ¦œ</text>
    <view class="tab-bar">
      <text class="tab {{currentTab === 'daily' ? 'active' : ''}}" bindtap="switchTab" data-tab="daily">ä»Šæ—¥</text>
      <text class="tab {{currentTab === 'weekly' ? 'active' : ''}}" bindtap="switchTab" data-tab="weekly">æœ¬å‘¨</text>
      <text class="tab {{currentTab === 'all' ? 'active' : ''}}" bindtap="switchTab" data-tab="all">æ€»æ¦œ</text>
    </view>
  </view>

  <view class="ranking-list">
    <view class="ranking-item" wx:for="{{rankingList}}" wx:key="id">
      <view class="rank-number rank-{{index + 1}}">{{index + 1}}</view>
      <image class="user-avatar" src="{{item.avatar}}"></image>
      <text class="user-name">{{item.name}}</text>
      <text class="user-points">{{item.points}} åˆ†</text>
    </view>
  </view>

  <view class="my-ranking">
    <text>æˆ‘çš„æ’åï¼šç¬¬ {{myRank}} å</text>
    <text>{{myPoints}} åˆ†</text>
  </view>
</view>
```

---

## ğŸ“‹ å®æ–½æ£€æŸ¥æ¸…å•

- [ ] é›†æˆè¯­éŸ³è¯„æµ‹åŠŸèƒ½
- [ ] æ·»åŠ å½•éŸ³åŠŸèƒ½
- [ ] å®ç°ç§¯åˆ†ç³»ç»Ÿ
- [ ] æ·»åŠ æˆå°±ç³»ç»Ÿ
- [ ] ä¼˜åŒ– UI åŠ¨ç”»
- [ ] å®ç°æ‹ç…§æ‰¹æ”¹
- [ ] å¼€å‘æ’è¡Œæ¦œ
- [ ] æ·»åŠ è¿å‡»æ•ˆæœ
- [ ] å®ç°ç­‰çº§ç³»ç»Ÿ
- [ ] ç”¨æˆ·æµ‹è¯•

---

## ğŸ¬ æµ‹è¯•è®¡åˆ’

### åŠŸèƒ½æµ‹è¯•
1. è¯­éŸ³è¯„æµ‹å‡†ç¡®æ€§
2. ç§¯åˆ†è®¡ç®—æ­£ç¡®æ€§
3. æˆå°±è§£é”é€»è¾‘
4. æ‹ç…§è¯†åˆ«å‡†ç¡®ç‡
5. æ’è¡Œæ¦œå®æ—¶æ€§

### æ€§èƒ½æµ‹è¯•
1. é¡µé¢åŠ è½½é€Ÿåº¦
2. åŠ¨ç”»æµç•…åº¦
3. ç½‘ç»œè¯·æ±‚ä¼˜åŒ–
4. å†…å­˜å ç”¨

### ç”¨æˆ·æµ‹è¯•
1. 5-10 åå­¦ç”Ÿè¯•ç”¨
2. æ”¶é›†åé¦ˆæ„è§
3. è¿­ä»£ä¼˜åŒ–

---

**ä¼˜åŒ–ç›®æ ‡**:
- ç”¨æˆ·ç•™å­˜ç‡æå‡ 30%
- æ—¥æ´»è·ƒæ—¶é•¿å¢åŠ  50%
- ç”¨æˆ·æ»¡æ„åº¦è¾¾åˆ° 4.5/5

**é¢„è®¡å®Œæˆæ—¶é—´**: 2 å‘¨
